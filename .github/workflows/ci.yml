name: CI Pipeline

on:
<<<<<<< HEAD
=======
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  MODE: ${{ vars.MODE || 'sandbox' }}

permissions:
  contents: write
  actions: write
  id-token: write

jobs:
  preflight:
    name: Preflight & validate generation artifacts
    runs-on: ubuntu-latest
    outputs:
      has-generated-files: ${{ steps.check.outputs.has_generated }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download generation reports (if present)
        if: github.event_name == 'pull_request'
        uses: actions/download-artifact@v3
        with:
          name: generation-reports
          path: generated-artifacts
        continue-on-error: true

      - name: Check for generated_files.json
        id: check
        run: |
          if [ -f generated-artifacts/reports/generated_files.json ]; then
            echo "has_generated=true" >> $GITHUB_OUTPUT
          else
            echo "has_generated=false" >> $GITHUB_OUTPUT
          fi

  lint:
    name: Lint (flake8)
    runs-on: ubuntu-latest
    needs: preflight
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install flake8
        run: pip install flake8

      - name: Run flake8 and save log
        run: |
          set -o pipefail
          flake8 . 2>&1 | tee flake8.log || rc=$?
          rc=${rc:-0}
          # In compliance mode, fail the job if flake8 produced any output
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "Failing because MODE=compliance and lint produced output" >&2
            exit $rc
          fi

      - name: Upload flake8 log
        uses: actions/upload-artifact@v4
        with:
          name: flake8.log
          path: flake8.log

  test:
    name: Test (pytest)
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt || true; fi
          pip install pytest

      - name: Run pytest and save results
        run: |
          set -o pipefail
          pytest --maxfail=1 --disable-warnings -q --junitxml=pytest-results.xml 2>&1 | tee pytest.log || rc=$?
          rc=${rc:-0}
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "Tests failed in compliance mode (rc=$rc)" >&2
            exit $rc
          fi
          # In sandbox, do not fail the workflow here - allow downstream jobs

      - name: Upload pytest artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results
          path: |
            pytest-results.xml
            pytest.log

  docker-build:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image and save logs
        run: |
          set -o pipefail
          docker build -t goose-app:${{ github.sha }} . 2>&1 | tee docker.log || rc=$?
          rc=${rc:-0}
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "Docker build failed in compliance mode" >&2
            exit $rc
          fi
          if docker images --format '{{"{{.Repository}}:{{.Tag}}"}}' | grep -q "goose-app:${{ github.sha }}"; then
            docker save goose-app:${{ github.sha }} -o goose-app-${{ github.sha }}.tar || true
          fi

      - name: Upload docker artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-artifacts
          path: |
            docker.log
            goose-app-${{ github.sha }}.tar

  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: [docker-build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate SBOM with Syft
        run: |
          docker run --rm -v "$PWD":/src anchore/syft:latest sh -c "syft /src -o cyclonedx-json > /src/sbom.json" || rc=$?
          rc=${rc:-0}
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "SBOM generation failed in compliance mode" >&2
            exit $rc
          fi

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom.json
          path: sbom.json

  sast:
    name: SAST (CodeQL)
    runs-on: ubuntu-latest
    needs: [sbom]
    continue-on-error: ${{ env.MODE == 'sandbox' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2

      - name: Analyze
        uses: github/codeql-action/analyze@v2

  audit:
    name: Trigger Audit Trail
    runs-on: ubuntu-latest
    needs: [sast]
    steps:
      - name: Gather artifacts for audit
        run: |
          mkdir -p audit-uploads || true
          # Try to download previously-uploaded generation reports (if PR from generator)
          if [ -d generated-artifacts ]; then
            cp -r generated-artifacts reports || true
          fi

      - name: Trigger audit-trail workflow via repository dispatch
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_GH_TOKEN }}
        run: |
          set -e
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{"event_type":"trigger-audit","client_payload":{"source_workflow":"ci.yml","sha":"'"${{ github.sha }}"'"}}' \
            | tee audit_response.json || true

      - name: Upload audit response
        uses: actions/upload-artifact@v4
        with:
          name: audit-response
          path: audit_response.json
  enforce-compliance:
    name: Enforce Compliance
    runs-on: ubuntu-latest
    needs: [lint, test, docker-build, sbom, sast]
    # Force compliance mode when the branch/PR head starts with auto/spec-implementation
    env:
      MODE: ${{ ((github.event_name == 'pull_request' && startsWith(github.head_ref, 'auto/spec-implementation')) || startsWith(github.ref, 'refs/heads/auto/spec-implementation')) && 'compliance' || vars.MODE || 'sandbox' }}
    if: ${{ env.MODE == 'compliance' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Download generation artifacts
        uses: actions/download-artifact@v3
        with:
          name: generation-reports
          path: ./generated

      - name: Validate spec coverage (strict in compliance)
        run: |
          set -o pipefail
          if [ "${MODE}" = "compliance" ]; then
            python3 scripts/validate_spec_coverage.py --report ./generated/spec-coverage.json
          else
            python3 scripts/validate_spec_coverage.py --report ./generated/spec-coverage.json || echo "Warning: spec coverage issues"
          fi

      - name: Detect manual edits outside generated/
        run: |
          set -euo pipefail
          if [ "${MODE}" = "compliance" ]; then
            git fetch --no-tags --depth=1 origin ${GITHUB_BASE_REF:-main} || true
            CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} || true)
            echo "$CHANGED" | grep -E '(^src/|^tests/)' | grep -v '^generated/' && {
              echo "Direct edits to src/ or tests/ outside generated/ detected. Failing compliance."
              exit 1
            } || echo "No disallowed edits found"
          else
            echo "Sandbox mode: manual edits allowed"
          fi

      - name: Run auditor (produces audit-response.json)
        run: |
          set -o pipefail
          python3 scripts/audit_compliance.py \
            --mode compliance \
            --pr-number "${{ github.event.pull_request.number || 'manual' }}" \
            --pr-author "${{ github.event.pull_request.user.login || github.actor }}" \
            --commit-sha "${{ github.sha }}" \
            --output ./audit-response.json \
            --spec-report ./generated/spec-coverage.json \
            --generated-files ./generated/generated_files.json

      - name: Ensure audit-response.json exists
        run: |
          if [ ! -f ./audit-response.json ]; then
            echo "Expected audit-response.json missing" >&2
            ls -la ./generated || true
            exit 1
          fi

      - name: Show audit-response.json
        if: always()
        run: |
          if [ -f ./audit-response.json ]; then
            echo "==== audit-response.json ===="
            cat ./audit-response.json
            jq -r '"Validator Exit Code: \(.validator_exit_code)\nAuditor Exit Code: \(.auditor_exit_code)"' ./audit-response.json 2>/dev/null || true
            echo "============================"
          else
            echo "No audit-response.json found"
          fi

      - name: Upload audit-response.json
        uses: actions/upload-artifact@v4
        with:
          name: audit-response
          path: ./audit-response.json
      - name: Always upload logs/artifacts (final step)
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: enforce-compliance-artifacts
          path: |
            audit-response.json
            pytest-results.xml
            flake8.log
            docker.log
            sbom.json
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  # Default mode is 'sandbox'. Override with repository variable `MODE` or set in environment.
  MODE: ${{ vars.MODE || 'sandbox' }}

jobs:
  lint:
    name: Lint (flake8)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install flake8
        run: pip install flake8

      - name: Run flake8 and save log
        run: |
          set -o pipefail
          flake8 . 2>&1 | tee flake8.log || true
          # In compliance mode, fail the job if flake8 produced any output (non-zero exit code)
          if [ "${{ env.MODE }}" = "compliance" ]; then
            if [ -s flake8.log ]; then
              echo "Failing because MODE=compliance and lint produced output" >&2
              exit 1
            fi
          fi

      - name: Upload flake8 log
        uses: actions/upload-artifact@v4
        with:
          name: flake8.log
          path: flake8.log

  test:
    name: Test (pytest)
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt || true; fi
          pip install pytest

      - name: Run pytest and save results
        run: |
          pytest --maxfail=1 --disable-warnings -q --junitxml=pytest-results.xml || rc=$?; rc=${rc:-0}
          # If compliance, fail on test failures
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "Tests failed in compliance mode (rc=$rc)" >&2
            exit $rc
          fi
          # Always exit 0 in sandbox to allow downstream jobs to run
          exit 0

      - name: Upload pytest results
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results.xml
          path: pytest-results.xml

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image and save logs
        run: |
          set -o pipefail
          docker build -t goose-app:${{ github.sha }} . 2>&1 | tee docker.log || rc=$?
          rc=${rc:-0}
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "Docker build failed in compliance mode" >&2
            exit $rc
          fi
          # Save image tarball for inspection/consumption
          if docker images --format '{{"{{.Repository}}:{{.Tag}}"}}' | grep -q "goose-app:${{ github.sha }}"; then
            docker save goose-app:${{ github.sha }} -o goose-app-${{ github.sha }}.tar || true
          fi

      - name: Upload docker artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-artifacts
          path: |
            docker.log
            goose-app-${{ github.sha }}.tar

  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: docker
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate SBOM with Syft (via Docker)
        run: |
          # Try to generate a CycloneDX SBOM for the repository
          docker run --rm -v "$PWD":/src anchore/syft:latest sh -c "syft /src -o cyclonedx-json > /src/sbom.json" || rc=$?
          rc=${rc:-0}
          if [ "${{ env.MODE }}" = "compliance" ] && [ "$rc" != "0" ]; then
            echo "SBOM generation failed in compliance mode" >&2
            exit $rc
          fi

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom.json
          path: sbom.json

  sast:
    name: SAST (CodeQL)
    runs-on: ubuntu-latest
    needs: sbom
    continue-on-error: ${{ env.MODE == 'sandbox' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python

      - name: Autobuild (optional)
        uses: github/codeql-action/autobuild@v2

      - name: Perform CodeQL analysis
        uses: github/codeql-action/analyze@v2

  audit:
    name: Trigger Audit Trail
    runs-on: ubuntu-latest
    needs: sast
    steps:
      - name: Trigger audit-trail workflow via repository dispatch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          RESPONSE_FILE=audit_response.json
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{"event_type":"trigger-audit","client_payload":{"source_workflow":"ci.yml","sha":"'"${{ github.sha }}"'"}}' \
            | tee $RESPONSE_FILE || true
          cat $RESPONSE_FILE > audit.log || true

      - name: Upload audit log
        uses: actions/upload-artifact@v4
        with:
          name: audit.log
          path: audit.log
name: CI Pipeline

on:
>>>>>>> auto/spec-broken-test
  pull_request:
  push:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - run: pip install flake8
      - run: flake8 src tests

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - run: pip install -r requirements.txt
      - run: pytest --maxfail=1 --disable-warnings -q

  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: github/codeql-action/init@v2
        with:
          languages: python
      - uses: github/codeql-action/analyze@v2

  docker-build:
    runs-on: ubuntu-latest
    needs: [lint, test, sast]
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker build -t example-service:${{ github.sha }} .

  sbom-sign:
    runs-on: ubuntu-latest
    needs: docker-build
    steps:
      - uses: actions/checkout@v3
      - name: Generate SBOM
        run: |
          pip install cyclonedx-bom
          cyclonedx-py -o sbom.xml
      - name: Sign image (cosign)
<<<<<<< HEAD
        run: |
          # Placeholder signing; replace with real cosign invocation
          echo "placeholder for cosign signing"
      - name: Update staging manifest
        run: |
          # Placeholder: Update staging manifest
          echo "placeholder: update staging-env manifest"
=======
        run: echo "placeholder for cosign signing"
      # Placeholder: after docker build, update staging-env manifest (to be implemented)
>>>>>>> auto/spec-broken-test
